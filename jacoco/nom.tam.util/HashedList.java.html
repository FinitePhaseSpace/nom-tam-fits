<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HashedList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.util</a> &gt; <span class="el_source">HashedList.java</span></div><h1>HashedList.java</h1><pre class="source lang-java linenums">package nom.tam.util;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 2004 - 2015 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

/**
 * This class implements a structure which can
 * be accessed either through a hash or
 * as linear list. Only some elements may have
 * a hash key.
 *
 * This class is motivated by the FITS header
 * structure where a user may wish to go through
 * the header element by element, or jump directly
 * to a given keyword. It assumes that all
 * keys are unique. However, all elements in the
 * structure need not have a key.
 *
 * This class does only the search structure
 * and knows nothing of the semantics of the
 * referenced objects.
 *
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * a ordered hash map implementation.
 *
 * @param &lt;VALUE&gt;
 *            value of the map
 */
<span class="fc" id="L66">public class HashedList&lt;VALUE extends CursorValue&lt;String&gt;&gt; implements Collection&lt;VALUE&gt; {</span>

    private static final class EntryComparator&lt;VALUE extends CursorValue&lt;String&gt;&gt; implements Comparator&lt;VALUE&gt; {

        private final Comparator&lt;String&gt; comp;

<span class="fc" id="L72">        private EntryComparator(Comparator&lt;String&gt; comp) {</span>
<span class="fc" id="L73">            this.comp = comp;</span>
<span class="fc" id="L74">        }</span>

        @Override
        public int compare(VALUE o1, VALUE o2) {
<span class="fc" id="L78">            return this.comp.compare(o1.getKey(), o2.getKey());</span>
        }
    }

    private class HashedListIterator implements Cursor&lt;String, VALUE&gt; {

        /**
         * This index points to the value that would be returned in the next
         * 'next' call.
         */
        private int current;

<span class="fc" id="L90">        HashedListIterator(int start) {</span>
<span class="fc" id="L91">            this.current = start;</span>
<span class="fc" id="L92">        }</span>

        @Override
        public void add(String key, VALUE ref) {
<span class="fc" id="L96">            add(ref);</span>
<span class="fc" id="L97">        }</span>

        @Override
        public void add(VALUE reference) {
<span class="fc" id="L101">            HashedList.this.add(this.current++, reference);</span>
<span class="fc" id="L102">        }</span>

        @Override
        public VALUE end() {
<span class="fc" id="L106">            this.current = Math.max(0, HashedList.this.ordered.size() - 1);</span>
<span class="fc" id="L107">            return next();</span>
        }

        @Override
        public boolean hasNext() {
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">            return this.current &gt;= 0 &amp;&amp; this.current &lt; HashedList.this.ordered.size();</span>
        }

        @Override
        public boolean hasPrev() {
<span class="fc bfc" id="L117" title="All 2 branches covered.">            return this.current &gt; 0;</span>
        }

        @Override
        public VALUE next() {
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">            if (this.current &lt; 0 || this.current &gt;= HashedList.this.ordered.size()) {</span>
<span class="fc" id="L123">                throw new NoSuchElementException(&quot;Outside list&quot;);</span>
            } else {
<span class="fc" id="L125">                VALUE entry = HashedList.this.ordered.get(this.current);</span>
<span class="fc" id="L126">                this.current++;</span>
<span class="fc" id="L127">                return entry;</span>
            }
        }

        @Override
        public VALUE next(int count) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (int index = 1; index &lt; count; index++) {</span>
<span class="fc" id="L134">                next();</span>
            }
<span class="fc" id="L136">            return next();</span>
        }

        @Override
        public VALUE prev() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (this.current &lt;= 0) {</span>
<span class="fc" id="L142">                throw new NoSuchElementException(&quot;Before beginning of list&quot;);</span>
            }
<span class="fc" id="L144">            return HashedList.this.ordered.get(--this.current);</span>
        }

        @Override
        public void remove() {
<span class="pc bpc" id="L149" title="2 of 4 branches missed.">            if (this.current &gt; 0 &amp;&amp; this.current &lt;= HashedList.this.ordered.size()) {</span>
<span class="fc" id="L150">                HashedList.this.remove(--this.current);</span>
            }
<span class="fc" id="L152">        }</span>

        @Override
        public void setKey(String key) {
<span class="fc" id="L156">            VALUE entry = HashedList.this.keyed.get(key);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (entry != null) {</span>
<span class="fc" id="L158">                this.current = indexOf(entry);</span>
            } else {
<span class="fc" id="L160">                this.current = HashedList.this.ordered.size();</span>
            }
<span class="fc" id="L162">        }</span>
    }

    /** An ordered list of the keys */
<span class="fc" id="L166">    private final ArrayList&lt;VALUE&gt; ordered = new ArrayList&lt;VALUE&gt;();</span>

    /** The key value pairs */
<span class="fc" id="L169">    private final HashMap&lt;String, VALUE&gt; keyed = new HashMap&lt;String, VALUE&gt;();</span>

    /**
     * Add an element to the list at a specified position. If that element was
     * already in the list, it is first removed from the list then added again
     * - if it was removed from a position before the position where it was to
     * be added, that position is decremented by one.
     *
     * @param pos
     *            The position at which the specified element is to be added.
     *            If pos is bigger than the size of the list the element is
     *            put at the end of the list.
     * @param reference
     *            The element to add to the list.
     */
    private void add(int pos, VALUE reference) {
<span class="fc" id="L185">        VALUE entry = reference;</span>
<span class="fc" id="L186">        String key = entry.getKey();</span>
<span class="fc bfc" id="L187" title="All 4 branches covered.">        if (this.keyed.containsKey(key) &amp;&amp; !unkeyedKey(key)) {</span>
<span class="fc" id="L188">            int oldPos = indexOf(entry);</span>
<span class="fc" id="L189">            this.keyed.remove(key);</span>
<span class="fc" id="L190">            this.ordered.remove(oldPos);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (oldPos &lt; pos) {</span>
<span class="fc" id="L192">                pos--;</span>
            }
        }
<span class="fc" id="L195">        this.keyed.put(key, entry);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (pos &gt;= this.ordered.size()) {</span>
<span class="fc" id="L197">            this.ordered.add(entry);</span>
        } else {
<span class="fc" id="L199">            this.ordered.add(pos, entry);</span>
        }
<span class="fc" id="L201">    }</span>

    private static boolean unkeyedKey(String key) {
<span class="fc bfc" id="L204" title="All 6 branches covered.">        return &quot;COMMENT&quot;.equals(key) || &quot;HISTORY&quot;.equals(key) || key.trim().isEmpty();</span>
    }

    @Override
    public boolean add(VALUE e) {
<span class="fc" id="L209">        add(this.ordered.size(), e);</span>
<span class="fc" id="L210">        return true;</span>
    }

    @Override
    public boolean addAll(Collection&lt;? extends VALUE&gt; c) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (VALUE element : c) {</span>
<span class="fc" id="L216">            add(element);</span>
<span class="fc" id="L217">        }</span>
<span class="fc" id="L218">        return true;</span>
    }

    @Override
    public void clear() {
<span class="fc" id="L223">        this.keyed.clear();</span>
<span class="fc" id="L224">        this.ordered.clear();</span>
<span class="fc" id="L225">    }</span>

    @Override
    public boolean contains(Object o) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (VALUE entry : this.ordered) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (o.equals(entry)) {</span>
<span class="fc" id="L231">                return true;</span>
            }
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">        return false;</span>
    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; c) {
<span class="fc" id="L239">        List&lt;?&gt; values = new ArrayList&lt;Object&gt;(c);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (VALUE entry : this.ordered) {</span>
<span class="fc" id="L241">            values.remove(entry);</span>
<span class="fc" id="L242">        }</span>
<span class="fc" id="L243">        return values.isEmpty();</span>
    }

    /**
     * @return &lt;code&gt;true&lt;/code&gt; if the key is included in the list.
     * @param key
     *            the key to search
     */
    public boolean containsKey(Object key) {
<span class="fc" id="L252">        return this.keyed.containsKey(key);</span>
    }

    /**
     * @return the n'th entry from the beginning.
     * @param n
     *            the index to get
     */
    public VALUE get(int n) {
<span class="fc" id="L261">        return this.ordered.get(n);</span>
    }

    /**
     * @return the value of a keyed entry. Non-keyed entries may be returned by
     *         requesting an iterator.
     * @param key
     *            the key to search for
     */
    public VALUE get(Object key) {
<span class="fc" id="L271">        return this.keyed.get(key);</span>
    }

    // Note that, if the entry is not found, a NoSuchElementException is
    // thrown instead of returning -1 (as is usual in indexOf methods) because
    // the method is used internally in situations where the entry must be
    // there.
    int indexOf(VALUE entry) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (int index = 0; index &lt; this.ordered.size(); index++) {</span>
<span class="fc" id="L280">            String searchKey = entry.getKey();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (searchKey.equals(this.ordered.get(index).getKey())) {</span>
<span class="fc" id="L282">                return index;</span>
            }
        }
<span class="fc" id="L285">        throw new NoSuchElementException(&quot;Internal error: &quot; + entry + &quot; should have been found in &quot; + ordered);</span>
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L290">        return this.ordered.isEmpty();</span>
    }

    /**
     * @return a HashedListIterator over the entire list.
     */
    @Override
    public HashedListIterator iterator() {
<span class="fc" id="L298">        return new HashedListIterator(0);</span>
    }

    /**
     * @return an iterator starting with the n'th entry.
     * @param n
     *            the index to start the iterator
     */
    public Cursor&lt;String, VALUE&gt; iterator(int n) {
<span class="fc bfc" id="L307" title="All 4 branches covered.">        if (n &gt;= 0 &amp;&amp; n &lt;= this.ordered.size()) {</span>
<span class="fc" id="L308">            return new HashedListIterator(n);</span>
        } else {
<span class="fc" id="L310">            throw new NoSuchElementException(&quot;Invalid index for iterator:&quot; + n);</span>
        }
    }

    /**
     * @return an iterator over the list starting with the entry with a given
     *         key.
     * @param key
     *            the key to use as a start point
     */
    public HashedListIterator iterator(String key) {
<span class="fc" id="L321">        VALUE entry = this.keyed.get(key);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L323">            return new HashedListIterator(indexOf(entry));</span>
        } else {
<span class="fc" id="L325">            throw new NoSuchElementException(&quot;Unknown key for iterator:&quot; + key);</span>
        }
    }

    /**
     * Remove an object from the list giving the object index..
     * 
     * @param index
     *            the index to remove
     * @return true if the index was in range
     */
    public boolean remove(int index) {
<span class="fc bfc" id="L337" title="All 4 branches covered.">        if (index &gt;= 0 &amp;&amp; index &lt; this.ordered.size()) {</span>
<span class="fc" id="L338">            return internalRemove(index, this.ordered.get(index));</span>
        }
<span class="fc" id="L340">        return false;</span>
    }

    private boolean internalRemove(int index, VALUE entry) {
<span class="fc" id="L344">        this.keyed.remove(entry.getKey());</span>
<span class="fc" id="L345">        this.ordered.remove(index);</span>
<span class="fc" id="L346">        return true;</span>
    }

    @Override
    public boolean remove(Object o) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        for (int i = 0; i &lt; this.ordered.size(); i++) {</span>
<span class="fc" id="L352">            VALUE entry = this.ordered.get(i);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (o.equals(entry)) {</span>
<span class="fc" id="L354">                return internalRemove(i, entry);</span>
            }
        }
<span class="fc" id="L357">        return false;</span>
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L362">        boolean result = false;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (Object element : c.toArray()) {</span>
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">            result = remove(element) || result;</span>
        }
<span class="fc" id="L366">        return result;</span>
    }

    /**
     * Remove a keyed object from the list. Unkeyed objects can be removed from
     * the list using a HashedListIterator or using the remove(Object) method.
     * 
     * @param key
     *            the key to remove
     * @return &lt;code&gt;true&lt;/code&gt; if the key was removed
     */
    public boolean removeKey(Object key) {
<span class="fc" id="L378">        VALUE entry = this.keyed.get(key);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L380">            int index = indexOf(entry);</span>
<span class="fc" id="L381">            this.keyed.remove(key);</span>
<span class="fc" id="L382">            this.ordered.remove(index);</span>
<span class="fc" id="L383">            return true;</span>
        }
<span class="fc" id="L385">        return false;</span>
    }

    /**
     * Replace the key of a given element.
     *
     * @param oldKey
     *            The previous key. This key must be present in the hash.
     * @param newKey
     *            The new key. This key must not be present in the hash.
     * @return if the replacement was successful.
     */
    public boolean replaceKey(String oldKey, String newKey) {

<span class="fc bfc" id="L399" title="All 4 branches covered.">        if (!this.keyed.containsKey(oldKey) || this.keyed.containsKey(newKey)) {</span>
<span class="fc" id="L400">            return false;</span>
        }
<span class="fc" id="L402">        VALUE oldVal = this.keyed.get(oldKey);</span>
        // same entry in hashmap and ordered so only one change.
<span class="fc" id="L404">        this.keyed.remove(oldKey);</span>
<span class="fc" id="L405">        this.keyed.put(newKey, oldVal);</span>
<span class="fc" id="L406">        return true;</span>
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {

<span class="fc" id="L412">        Iterator&lt;VALUE&gt; iter = iterator();</span>
<span class="fc" id="L413">        boolean result = false;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L415">            Object o = iter.next();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (!c.contains(o)) {</span>
<span class="fc" id="L417">                iter.remove();</span>
<span class="fc" id="L418">                result = true;</span>
            }
<span class="fc" id="L420">        }</span>
<span class="fc" id="L421">        return result;</span>
    }

    @Override
    public int size() {
<span class="fc" id="L426">        return this.ordered.size();</span>
    }

    /**
     * Sort the keys into some desired order.
     * 
     * @param comp
     *            the comparator to use for the sorting
     */
    public void sort(final Comparator&lt;String&gt; comp) {
<span class="fc" id="L436">        java.util.Collections.sort(this.ordered, new EntryComparator&lt;VALUE&gt;(comp));</span>
<span class="fc" id="L437">    }</span>

    @Override
    public Object[] toArray() {
<span class="fc" id="L441">        return ordered.toArray();</span>
    }

    @Override
    public &lt;T&gt; T[] toArray(T[] o) {
<span class="fc" id="L446">        return ordered.toArray(o);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L451">        return this.ordered.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>